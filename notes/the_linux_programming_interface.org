* [[https://book.douban.com/subject/25809330/][Linux/UNIX系统编程手册]]

** 历史和标准

** 基本概念

** 系统编程概念

*** 系统调用

    1. 系统调用将处理器从用户态切换为核心态；
    2. 系统调用的组成是固定的，有唯一的、对外不可见的数字标识；
    3. 每个系统调用都有参数规范用户空间与内核空间之间的信息传递；

       某种意义上来说，C 函数中系统调用相关的函数，都是 wrapper，它们封装了对应的系统调用，使用这些函数的时候，会有两次次用户态跟核心态的切换。

*** 库函数

*** glibc

    1. 可以用 ldd 列出依赖的库；

*** 错误处理

    少数系统调用(比如 [[http://man7.org/linux/man-pages/man2/getpriority.2.html][getpriority()]] )调用成功也会返回 -1。

*** 可移植性问题

**** 特性测试宏

     通过定义特性测试宏，暴露对应特定标准的定义。

**** 系统数据类型

*** 练习

    =reboot= 第二个参数的 magic 数值转换成十六进制之后，其实就是 Linus 和他女儿的生日，见[[https://stackoverflow.com/questions/4808748/magic-numbers-of-the-linux-reboot-system-call][这个回答]]。


** 文件 I/O

*** =open()=

    1. 因为早期的 UNIX 实现，使用 0、1和2表示 =O_RDONLY=, =O_WRONLY= 和 =O_RDWR= 所以， =O_RDWR= 不等于 =O_RDONLY | O_WRONLY=[fn:1]。
    2. 新建文件的权限会依赖于 =open()= 的参数 mode 以及进程的 umask 值和父目录的默认访问控制列表。

*** =read()=

    1. =read()= 读取的字节数少于请求的字节数的情况：靠近 **普通文件** 尾部；管道、FIFO、socket 或者终端。
    2. C 语言里面调用 =read()= 还得手动加 ='\0= 。

*** =write()=

    1. 对磁盘文件执行 I/O 操作时， =write()= 成功并不能确保数据已经写入磁盘。因为内核会缓存磁盘的 I/O 操作。

*** =close()=
    
    1. 关闭文件可能的错误：关闭未打开或者已经关闭的文件。

*** =lseek()= 改变文件偏移量

    1. 并不适用于所有文件（如管道、FIFO、socket或者终端）。
    2. =lseek()= 之后再写入，可以导致文件空洞

*** 练习

    1. 写一个 tee
    2. 复制时带空洞

** Footnotes

[fn:1] 所以别乱用 
