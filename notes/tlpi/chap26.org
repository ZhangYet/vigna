** 监控子进程

本章主要讨论 ~wait()~ 调用。

*** 等待子进程

**** wait()

~pid_t wait(int *status)~ 所以说 c 语言真的挺麻烦的，需要一个整型指针来传递状态，然后通过一个 pid_t 值来指示那个子进程被返回了。

1. 阻塞进程，直到有子进程返回；
2. status 指示返回状态；
3. 内核会将父进程下所有的子进程的运行量追加到父进程中；
4. 将子进程 id 返回；

errno 为 ~ECHILD~ 时，表示没有要等待的子进程。

#+NAME: code-26.1
#+BEGIN_SRC c
while ((childPid = wait(NULL)) != -1)
    continue;
if (errno != ECHILD) 
    errExit("wait");
#+END_SRC

上面的代码片段展示了父进程等待所有子进程退出，并检查是否有非正常退出的情况。

**** waitpid()

~wait()~ 的局限：

1. 多个子进程的情况，无法等待特定的子进程，只能按顺序等待下一个进程终止；
2. 没有子进程的情况下， ~wait()~ 总是阻塞；
3. ~wait()~ 只能处理终止的子进程，对于因为某些信号(SIGSTOP 或 SIGTTIN)停止或者已经停止的子进程因为某些信号(SIGCONT)恢复执行的情况无能为力；

~pid_t waitpid(pid_t pid, int *status, int options)~

pid 的意义：

1. pid > 0, 等待 ID 为 pid 的子进程；
2. pid = 0, 等待与父进程同一进程组的所有子进程；
3. pid = -1, 等待所有子进程， ~wait(&status)~ 与 ~waitpid(-1, &status, 0)~ 等价；

options:

| options    | 含义                                                          |
|------------+---------------------------------------------------------------|
| WUNTRACED  | 除了返回终止子进程的信息外，还返回因信号而停止的子进程信息。  |
| WCONTINUED | 返回那些因收到SIGCONT信号而恢复执行的已停止子进程的状态信息。 |
| WHOHANG    | 如果参数pid所指定的子进程并未发生状态改变，则立即返回，而不会阻塞，亦即poll（轮询）。                                                              |

