** POSIX 消息队列

POSIX 消息队列居然没有 msgtype，只有优先级。但是允许异步通知。

*** 概述

*** 打开、关闭和断开

~mq_open()~ 创建或者打开已有的队列。

注意 fork 和 exec 对消息队列描述符的影响—— fork 出的子进程会继承打开的队列描述符，但是 exec 会关闭打开的队列描述符。

~mq_unlink()~ 删除消息队列，并将队列标识为所有进程使用完后销毁。

*** 描述符与队列的关系

跟文件描述符很相似。消息队列描述符是进程级别的，引用了系统级别的消息队列描述符表。简单来说就是不同进程不同描述符可能指向同一个队列。

*** 消息队列特性

创建队列时需要指定的特性：最多有多少消息；每条消息最多多大。内核可以根据这两个特性确定需要分配的内存。

#+BEGIN_QUOTE
SUSv3规定使用mq_setattr()能够修改的唯一特性是O_NONBLOCK标记的状态。

[德]Michael Kerrisk. Linux/UNIX系统编程手册(上、下册) (Chinese Edition) (Kindle位置18901). Kindle 版本. 
#+END_QUOTE

笑死。

*** 发送与接受

同优先级的消息 FIFO。感觉不是很灵活呢。

*** 消息通知

进程可以通过 ~ms_notify()~ 定于一个消息队列，这个队列由空变非空的时候，订阅进程会收到通知。

细节：

1. 每个队列只有一个进程可以订阅。
2. 只有从空变非空的时候才会通知。
3. 通知一次就要重新订阅。
4. 如果有别的进程订阅队列并且阻塞在 ~mq_receive()~,那也不会收到消息（因为要把消息给阻塞的进程消费）。

一般会这样写：接收通知，进入消息处理程序，重新订阅队列，之后消费所有消息（注意顺序，要在消费之前定于，因为只有从空到非空才会通知）。

*** Linux 属性

select 与 epoll
