** 管道和 FIFO

*** 概述

1. 一个管道是一个字节流——无法随机访问数据，只能顺序写入，顺序读取。
2. 从管道读取数据会被阻塞，写入结束后，管道会读到 EOF。
3. 管道是单向的。
4. 可以确保写入不超过PIPE_BUF字节的操作是原子的。
5. 管道容量是有限的——一旦满了，写入就会阻塞。

*** 创建和使用管道

一般来说，创建了管道之后，写端会关闭读的描述符，读端会关闭写的描述符。

为什么一定要关闭呢？

1. 节省描述符。
2. 读端关闭写描述符，这样写完之后能看到 EOF，否则 read 会一直阻塞。
3. 如果写入进程没有关闭管道的读取端，那么即使在其他进程已经关闭了管道的读取端之后写入进程仍然能够向管道写入数据，最后写入进程会将数据充满整个管道，后续的写入请求会被永远阻塞。
4. 一个管道只有在所有的读写描述符关闭之后才会释放资源。

*** 将管道用作进程同步的方法

跟 channel 很相似，子进程持有写描述符，父进程持有读描述符。子进程写完关闭描述符，父进程接收 EOF 知道子进程完事了。

*** 使用管道链接过滤器

使用 dup/dup2 将 STDIN/STDOUT 改成对应的管道文件描述符。

*** ~popen()~

~popen()~ 会创建一个管道，创建一个 shell，创建一个子进程运行命令，并根据 mode 参数确定是将结果写入管道还是从管道读取数据。

*** stdio 缓冲

因为 pipe 使用块缓存，所以在缓存满之前，输出是不会发送的的。写端可以通过 ~fflush()~ 或者 ~setbuf()~ 来解决，读端就比较复杂，在不能修改写端的情况下，得用伪终端。

*** FIFO

FIFO 也称为有名管道。

还有 tee 这个工具，也很有意思。
