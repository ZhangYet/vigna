#+TITLE: 系统设计
* 设计问题
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
** 缓存设计
*** 缓存主要用在哪些场景？

*** 缓存更新策略的优劣
主要看[[https://coolshell.cn/articles/17416.html][这篇]]。

*Q* 为什么不采用先删除再更新数据库的方式？

*A* 考虑这样一种场景：更新数据库的时候有一个并发读的操作，这个时候，并发读将旧数据写入缓存中。

**** cache aside
1. 失效：优先从缓存读取,如果没有，从数据库获取然后更新内存；
2. 命中；
3. 更新，更新数据库，然后使缓存失效；

一种很小概率的问题：读的同时并发来了写，写完删除缓存读还没有完成，读的请求会将旧数据写回缓存中。

**** read/write through 

缓存自己在 read 或者 write 的时候更数据。

1. write： Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）
2. read：Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。

**** write behide caching

只更新缓存，直到一定时间再 flush 到后面的存储。

*** 缓存需要考虑的问题

1. 缓存时长；
2. 缓存失效处理（按时失效、事件失效、主动更新）；
3. 缓存键设计；
4. 缓存的内容及数据结构；
5. 缓存雪崩的处理（缓存服务器重启或者大量缓存在同一时间失效）；
6. 缓存穿透的处理（此外防止恶意访问）

*** 基本的技术选型

** 队列推拉问题

https://tech.meituan.com/2016/07/01/mq-design.html

1. 顺序问题：pull 优于 push；
2. 消息延迟与忙等： push 优于 pull，pull 无法准确得知何时去拉取最新消息；
3. 慢消费： pull 优于 push，push 要等消费者消费完，broker 会堆积消息，pull 情况下 broker 只需要保持 offset 即可；

** KV 设计

[[https://tech.meituan.com/2020/07/01/kv-squirrel-cellar.html][美团万亿级 KV 存储架构与实践]]

*** 历史演进

1. Memcached 实例+一致性哈希：宕机会丢数据；
2. redis 主从：扩容和缩容时一致性哈希依然会丢数据；为什么一致性哈希会丢数据？一致性哈希算法并不能杜绝数据迁移的问题，但是可以有效避免数据的全量迁移，需要迁移的只是更改的节点和它的上游节点它们两个节点之间的那部分数据。
3. 阿里 tair：脑裂解决不了，数据结构不够丰富。
4. redis -> squirrel(数据量小，延迟敏感)。
5. tair -> cellar(数据量大，延迟不敏感)。

*** squirrel 方案

**** 基本架构

 [[https://p0.meituan.net/travelcube/73d1e6275d385a0e973e378b69189ba5165460.png][squirrel 架构图]]

其实就是一个管理组件，通过 zookeeper 变更 redis 集群状态，客户端从 zookeeper 拿路由。节点有变，更新 zookeeper。

**** 节点容灾

感觉就是优化了从节点的健康检查：从节点的网络状态有变，路由打到另外一个从节点上，如果有故障的从节点永久下线了，重新申请一个新的节点加进来。

**** 跨机房容灾

***** 数据迁移

#+BEGIN_QUOTE
我们会用监控服务去实时采集客户端的成功率、耗时，服务端的负载、QPS 等，之后把这个状态反馈到迁移机上。迁移数据的过程就类似 TCP 慢启动的过程，它会把速度一直往上加，若出现请求成功率下降等情况，它的速度就会降低，最终迁移速度会在动态平衡中稳定下来，这样就达到了最快速的迁移，同时又尽可能小地影响业务的正常请求。
#+END_QUOTE

#+BEGIN_QUOTE
我们看一下大 Value 的迁移，我们实现了一个异步 Migrate 命令，该命令执行时，Redis 的主线程会继续处理其他的正常请求。如果此时有对正在迁移 Key 的写请求过来，Redis 会直接返回错误。这样最大限度保证了业务请求的正常处理，同时又不会阻塞主线程。
#+END_QUOTE

所以其实就是有调度的迁移。

***** 持久化

这里问题和解法都没有看懂。

***** 热点 key

区分热点 key，对 key 读写做统计，热点 key 单独放别的实例（集群）里面。

*** cellar 方案
先跳过。
