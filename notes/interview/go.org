* go 相关面试题

** goroutine 是什么？与线程和进程有什么区别？

与线程的区别在于：

1. 初始分配的栈空间很小2k；
2. goroutine 由 go runtime 调度，不需要系统调用（免去内核态和用户态的交互）；
3. 上下文切换代价也更小；

见： https://studygolang.com/articles/23191

** GMP 模型简述

见：http://morsmachine.dk/go-scheduler

G: stack, the instruction pointer and other information important for scheduling goroutines 可以理解成实际要执行的程序。

M: OS thread.

P: a context for scheduling.

每个 P 有独立的 G 队列，从队列中消耗 G，如果有一个 G 因为系统调用阻塞，这个 G 被移到一个空闲的（或者新的） M 上面，直到阻塞结束，再找一个 P 完成，空闲的 P 会从全局队列或者其他 P 的队列中抢 G。


** go struct 能不能比较？

不能，同struck 的实例可以比较。

** go slice 内存管理

明天要总结一下[[https://blog.golang.org/go-slices-usage-and-internals][这篇文章]]。

** 为什么 channel 是线程安全的

没啥好解答。

** go sync 锁的分类和原理

** go 内存垃圾回收

** 什么是 interface

** 如何优雅关闭 go channel

#+BEGIN_QUOTE
One general principle of using Go channels is don't close a channel from the receiver side and don't close a channel if the channel has multiple concurrent senders. In other words, we should only close a channel in a sender goroutine if the sender is the only sender of the channel.

https://go101.org/article/channel-closing.html
#+END_QUOTE

** [[https://reading.developerlearning.cn/interview/#][面试专题]]

*** 面试题解析一

**** defer 的问题

#+BEGIN_SRC go
package main

import (
    "fmt"
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println("打印前") }()
    defer func() { fmt.Println("打印中") }()
    defer func() { fmt.Println("打印后") }()

    panic("触发异常")
}
#+END_SRC

defer 是后进先出的，所以后面的 defer 会先输出，最后才输出 panic 的内容。

**** range 的问题

#+BEGIN_SRC go
import (
	"fmt"
)

type student struct {
	Name string
	Age  int
}

func parse_student() map[string]*student{
	m := make(map[string]*student)
	stus := []student{
		{Name: "zhou", Age: 24},
		{Name: "li", Age: 23},
		{Name: "wang", Age: 22},
	}
	for _, stu := range stus {
		m[stu.Name] = &stu
	}
	return m
}

func main() {
	m := parse_student()
	for k, v := range m{
		fmt.Printf("key: %s, Name %s: age: %d\n", k, v.Name, v.Age)
	}
}
#+END_SRC

上面代码的问题是 range 带来的，range 在处理遍历的时候，会把 value 赋值给一个临时变量，因为这中间存在了复制，所以所有指针都被复制成同一个了。把指针改成值就不会有这种烦恼了。

#+BEGIN_QUOTE
遇到这种同时遍历索引和元素的 range 循环时，Go 语言会额外创建一个新的 v2 变量存储切片中的元素，循环中使用的这个变量 v2 会在每一次迭代被重新赋值，在赋值时也发生了拷贝。

[[https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/#heading-4][《go 语言设计与实现》]]
#+END_QUOTE

**** goroutine 闭包

#+BEGIN_QUOTE go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	runtime.GOMAXPROCS(1)
	wg := sync.WaitGroup{}
	wg.Add(20)
	for i := 0; i < 10; i++ {
		go func() {
			fmt.Println("A: ", i)
			wg.Done()
		}()
	}
	for i := 0; i < 10; i++ {
	        go func(i int) {
			fmt.Println("B: ", i)
			wg.Done()
		}(i)
	}
	wg.Wait()
}
#+END_QUOTE

A 会输出随机字符（虽然实际上测试了好几次都是10），主要是因为 go func 中 i 是外部 for 的一个变量，地址不变化，但是值都在改变。

**** 组合继承

#+BEGIN_SRC go
package main

import "fmt"

type People struct{}

func (p *People) ShowA() {
	fmt.Println("showA")
	p.ShowB()
}
func (p *People) ShowB() {
	fmt.Println("showB")
}

type Teacher struct {
	People
}

func (t *Teacher) ShowB() {
	fmt.Println("teacher showB")
}

func main() {
	t := Teacher{}
	t.ShowA()
}
#+END_SRC

输出 "showA\nshowB"。

**** make 初始化问题

#+BEGIN_SRC go
package main

import "fmt"

func main() {
	s := make([]int, 5)
	s = append(s, 1, 2, 3)
	fmt.Println(s)
}
#+END_SRC

输出的结果是 ~[0 0 0 0 0 1 2 3]~, 原因是 [[https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/][make]] 会初始化对应的数据结构。

**** map 并发问题

并发读写的 map 的时候，可能会有 [[https://zhanghongtong.github.io/2018/07/04/golang-map%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E4%25B8%258D%25E8%2583%25BD%25E5%25B9%25B6%25E5%258F%2591%25E8%25AF%25BB%25E5%2586%2599%25E9%2597%25AE%25E9%25A2%2598-fatal-error-concurrent-map-writes/][fatal error: concurrent map writes]]，解决办法大概就是 sync.Map.



