#+OPTIONS: ^:nil 
* 面经
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

** [[https://www.cnblogs.com/kubidemanong/p/10808107.html][腾讯二面面经]]

*** 为什么索引能加快速度

如果没有索引，就要全表扫描了，线性时间不说，磁盘 IO 的开销也会更大。

引申： *为什么 B+ 树能减少磁盘 IO ？*

通过『指针』依次按顺序连接，当我们在如下所示的 B+ 树遍历数据时可以直接在多个子节点之间进行跳转，这样能够节省大量的磁盘 I/O 时间，也不需要在不同层级的节点之间对数据进行拼接和排序；通过一个 B+ 树最左侧的叶子节点，我们可以像链表一样遍历整个树中的全部数据，我们也可以引入双向链表保证倒序遍历时的性能。

*** /proc 文件夹是用来干什么的？

这其实是一个虚拟的文件系统，展示内核信息。里面会有进程的各种信息，包括：

1. cmdline，参数；
2. cwd，当前工作目录的符号链接；
3. Environ， 环境变量；
4. fd，进程打开的文件的符号链接；
5. maps， 内存映射；
6. exe，正在执行的文件的符号链接；
7. mem，虚拟内存；
8. mounts，进程安装点；
9. root，根目录的符号链接；
10. status, 各种信息；
11. task，每个线程包含的子目录；

*** 如何查看端口情况

~lsof -i:端口号~

或者

~netstat -tunl |grep 端口号~

*** IO 的原子性

通过 ~O_EXCL~ 和 ~O_CREAT~ 标识，独占性创建文件，保证 *检查和创建文件的步骤属于单一的原子操作* 。

通过 ~O_APPEND~ 确保 *文件偏移量和数据写操作纳入统一原子操作* 。

*** 怎样查看进程状态

其实就是 ~ps aux | grep 进程号~ 

状态一览：

D 不可中断 Uninterruptible（usually IO）
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核2.6开始无效）
X 死掉的进程

*** 进程包含那些数据

进程是正在执行的程序实例，逻辑上包括：

1. 文本：程序的指令；
2. 数据：静态变量；
3. 堆：动态分配额外内存；
4. 栈：局部变量和函数调用链接信息的存储空间；

延伸： *什么是 daemon ？*
简单来说就是后台运行的进程，它不会有控制终端。一般是父进程创建子进程之后退出，子进程成为 init 的子进程，并释放跟控制终端之间的关联（还要关闭从父进程继承过来而打开的文件描述符）。有一个库函数 ~becomeDaemon~ 。

[[file:os.org::*%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B][孤儿进程/僵尸进程]]

*** 什么是线程

可以讲线程想象为共享同一虚拟内存以及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区和堆，但是有独立的栈。

