* [[https://book.douban.com/subject/33463930/][操作系统导论]]

** 操作系统介绍

重要问题： 

1. *操作系统如何讲资源虚拟化* 。
2. *如何正确处理并发* 。
3. *如何持久存储数据* 。

** 抽象：进程

进程三种状态：运行、就绪和阻塞。

** 进程 API
一个之前读 TLPI 没有留意的点：exec() 不返回，它后面的代码不会被执行。

** 受限直接运行

问题：如果对程序运行没有限制，那么我们怎样保证安全性，如何停下并切换？

方案：区分用户态和内核态，用户态下代码受限（比如不能发出 I/O）。内核态可以访问所有的资源。

内核 trap 表：记录那些异常对应那些代码。

问题： *如何重获 CPU 控制权* ？

方案一：等待系统调用。缺陷：我就是不用系统调用，你能奈我何？

方案二：非协作方式。时钟中断。

上下文切换：系统需要保存当前执行进程的寄存器的值，恢复将要执行的进程寄存器的值。

** 进程调度

   - Note taken on [2020-03-15 日 14:28] \\
     其实我觉得 STCF 还有个问题：系统怎么之后完成时间？
1. FIFO: 如果有某些任务占用时间特别多，那就 over 了。
2. SJF（最短任务优先）。处理不了任务随时进入的情况。
3. STCF（最短完成任务优先）。如果任务运行时间太长，新任务时间比它短，让新任务抢占它的时间。但是如果考虑响应时间（收到任务到任务被执行的时间），STCF 就不太好用了。
4. RR（轮转）。

两种策略：

SJF 和 STCF 优化了周转时间（任务结束时间），RR 优化了响应时间（但是对周转时间不利）。

再考虑 IO，还有系统不知道结束时间。

本章结束。

** 调度：多级反馈队列

MLFQ(Multi-level feedback quue)。

*** 基本规则

多个优先队列，每个队列用 RR 策略，核心就在于如果调整优先级。

规则1: 先运行高优先级的任务；

规则2：同优先级队列任务采用 RR；

*** 尝试1: 改变优先级

规则3: 任务进入系统时，放入最高优先级队列；

规则4a: 任务用完一个时间片之后，降低优先级；

规则4b 用完时间片前主动释放的任务，优先级不变；

这里假设了所有任务都是短任务，如果任务时间长，则会放入低优先级的队列，这跟 SJF 接近。

*MLFQ 的问题* ： 如果有大量交互式的任务（不断主动释放时间片的任务），长时间任务会得不到资源，进入饥饿状态。

*** 尝试2: 提高优先级

规则5: 经过一段时间之后，将所有任务都放进最高优先级的队列。

*** 尝试3: 更好的计时方式

（改写后的）规则4: 一旦任务用完某一层的时间配额（不管有没有自动释放），降低它的优先级。

** 调度：比例份额

** 多处理器调度

*** 多处理器架构

区别核心：硬件缓存的使用和多处理器之间数据共享。

三个问题：

1. 缓存一致性；
2. 同步（并发访问）；
3. 缓存亲和性（希望进程在同一个CPU上运行）；

*** 单队列调度

SQMS: 优点——简单，负载均衡好；缺点——扩展性，性能（因为要加锁），亲和性较差。

*** 多队列调度

MQMS：优点——可扩展，上锁的场景少；缺点——不均衡，解决方案—— work stealing。

** 地址空间
进程的地址空间包括运行中程序所有的内存状态：

1. 程序本身（文本段）；
2. 栈（当前函数调用信息、局部变量、参数和返回值）；
3. 堆（动态分配的内存）；
4. 静态初始化的变量；

虚拟内存的三个目标：透明、效率和保护。

** 内存操作 API

小知识：malloc 和 free 是 brk 的封装。

** 机制：地址转换

*** 动态（基于硬件）重定位

基址加界限机制（base and bound）亦即动态重定位。

每个 CPU 保留基址寄存器和界限寄存器，那么每个进程都能独享一块内存。硬件将虚拟内存加上基址就得到物理地址，发给内存系统。

上下文切换的时候必须更新基址和界限寄存器。

** 分段
如果将整个地址空间放入内存，堆和栈之间的内存空间其实闲置了。所以我们需要分段。

*** 泛化的基址/界限
简单来说就是程序、栈和堆的基址/界限是不同的。

*** 怎样知道用哪个基址/界限
1. 显式声明：在地址前两位标识该用哪个基址/界限；
2. 隐式声明：通过地址产生的方式确定；

*** 支持共享
保护位。

*** 留存问题
内存碎片。

** 空闲空间管理
