* [[https://book.douban.com/subject/33463930/][操作系统导论]]

** 操作系统介绍

重要问题： 

1. *操作系统如何讲资源虚拟化* 。
2. *如何正确处理并发* 。
3. *如何持久存储数据* 。

** 抽象：进程

进程三种状态：运行、就绪和阻塞。

** 进程 API
一个之前读 TLPI 没有留意的点：exec() 不返回，它后面的代码不会被执行。

** 受限直接运行

问题：如果对程序运行没有限制，那么我们怎样保证安全性，如何停下并切换？

方案：区分用户态和内核态，用户态下代码受限（比如不能发出 I/O）。内核态可以访问所有的资源。

内核 trap 表：记录那些异常对应那些代码。

问题： *如何重获 CPU 控制权* ？

方案一：等待系统调用。缺陷：我就是不用系统调用，你能奈我何？

方案二：非协作方式。时钟中断。

上下文切换：系统需要保存当前执行进程的寄存器的值，恢复将要执行的进程寄存器的值。

** 进程调度

   - Note taken on [2020-03-15 日 14:28] \\
     其实我觉得 STCF 还有个问题：系统怎么之后完成时间？
1. FIFO: 如果有某些任务占用时间特别多，那就 over 了。
2. SJF（最短任务优先）。处理不了任务随时进入的情况。
3. STCF（最短完成任务优先）。如果任务运行时间太长，新任务时间比它短，让新任务抢占它的时间。但是如果考虑响应时间（收到任务到任务被执行的时间），STCF 就不太好用了。
4. RR（轮转）。

两种策略：

SJF 和 STCF 优化了周转时间（任务结束时间），RR 优化了响应时间（但是对周转时间不利）。

再考虑 IO，还有系统不知道结束时间。

本章结束。

** 调度：多级反馈队列

MLFQ(Multi-level feedback quue)。

*** 基本规则

多个优先队列，每个队列用 RR 策略，核心就在于如果调整优先级。

规则1: 先运行高优先级的任务；

规则2：同优先级队列任务采用 RR；

*** 尝试1: 改变优先级

规则3: 任务进入系统时，放入最高优先级队列；

规则4a: 任务用完一个时间片之后，降低优先级；

规则4b 用完时间片前主动释放的任务，优先级不变；

这里假设了所有任务都是短任务，如果任务时间长，则会放入低优先级的队列，这跟 SJF 接近。

*MLFQ 的问题* ： 如果有大量交互式的任务（不断主动释放时间片的任务），长时间任务会得不到资源，进入饥饿状态。

*** 尝试2: 提高优先级

规则5: 经过一段时间之后，将所有任务都放进最高优先级的队列。

*** 尝试3: 更好的计时方式

（改写后的）规则4: 一旦任务用完某一层的时间配额（不管有没有自动释放），降低它的优先级。

** 调度：比例份额

** 多处理器调度

*** 多处理器架构

区别核心：硬件缓存的使用和多处理器之间数据共享。

三个问题：

1. 缓存一致性；
2. 同步（并发访问）；
3. 缓存亲和性（希望进程在同一个CPU上运行）；

*** 单队列调度

SQMS: 优点——简单，负载均衡好；缺点——扩展性，性能（因为要加锁），亲和性较差。

*** 多队列调度

MQMS：优点——可扩展，上锁的场景少；缺点——不均衡，解决方案—— work stealing。

** 地址空间
进程的地址空间包括运行中程序所有的内存状态：

1. 程序本身（文本段）；
2. 栈（当前函数调用信息、局部变量、参数和返回值）；
3. 堆（动态分配的内存）；
4. 静态初始化的变量；

虚拟内存的三个目标：透明、效率和保护。

** 内存操作 API

小知识：malloc 和 free 是 brk 的封装。

** 机制：地址转换

*** 动态（基于硬件）重定位

基址加界限机制（base and bound）亦即动态重定位。

每个 CPU 保留基址寄存器和界限寄存器，那么每个进程都能独享一块内存。硬件将虚拟内存加上基址就得到物理地址，发给内存系统。

上下文切换的时候必须更新基址和界限寄存器。

** 分段
如果将整个地址空间放入内存，堆和栈之间的内存空间其实闲置了。所以我们需要分段。

*** 泛化的基址/界限
简单来说就是程序、栈和堆的基址/界限是不同的。

*** 怎样知道用哪个基址/界限
1. 显式声明：在地址前两位标识该用哪个基址/界限；
2. 隐式声明：通过地址产生的方式确定；

*** 支持共享
保护位。

*** 留存问题
内存碎片。

** 空闲空间管理

** 分页
通过分页实现虚拟内存：将空间分割为固定长度的分片，比较方便清理碎片。

页表：保存每个页（虚拟地址）到物理内存的映射。这样内存的分配不需要连续的空间，内存可以碎，我们用起来还是整的。

32位内存空间，4KB的页，需要20位地址空间，12位偏移量。这样操作系统需要为每个进程保存 2^20 个地址转换（地址空间到实际物理内存的映射）。这些页表存在内存中。

** 分页：快速地址转换（TLB）
如果每次读取内存都要查页表，那么就太慢了。所以我们加缓存（TLB）。

** 分页：较小的表
基于数据的页表太大了，每个进程都有自己的页表，系统受不了。

*** 更大的页
真是简单粗暴，但是会造成内部碎片。

*** 分段与分页
这种方案没读懂。

*** 多级页表

** 使用磁盘

*** 交换空间
用硬盘中的空间保存内存的叶，这些空间称为交换空间（swap space）。

*** 交换策略
就是什么时候将内存页踢出去。

** 并发：介绍

一些概念：

PC： 程序计数器，不知道是哪个人起的名字，这明明是记录程序从哪里获取指令的东西，搞得好像是引用计数器一样。
PCB：进程控制块。
TCB：线程控制块。

注意线程也有上下文切换。但是线程切换的地址空间不变。但是每个线程有独立的栈。

** 锁

锁实现：

1. 控制中断：获得锁的时候关闭中断，释放锁的时候重启中断。这种方案缺陷很多，基本不会被使用了。
2. test-and-set instruction (TAS)，在软件层正确性都不能保证，挺呵呵的。需要硬件支持。如果处理器支持原子的 TAS ，那我们可以实现自旋锁。但是在单处理器上需要抢占式调度器配合（不然它能自旋到天荒地老）。
3. compare-and-swap (CAS)，这跟 TAS 有啥区别啊？
4. 其他。

自旋锁：满足正确性，但是缺乏公平性，多处理器下性能不错。

** 条件变量

生产者/消费者问题（有界缓冲区）。

** 信号量

我跳过这两章了。

** 常见的并发问题

*** 非死锁问题
主要是两种：违反原子性和违反顺序。

*** 死锁问题
死锁产生的四个条件：
1. 互斥；
2. 持有并等待；
3. 非抢占；
4. 循环等待；

** 基于事件的并发

基于事件的系统必须遵守：不允许阻塞调用。
