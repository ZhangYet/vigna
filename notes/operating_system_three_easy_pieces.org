* [[https://book.douban.com/subject/33463930/][操作系统导论]]

** 操作系统介绍

重要问题： 

1. *操作系统如何讲资源虚拟化* 。
2. *如何正确处理并发* 。
3. *如何持久存储数据* 。

** 抽象：进程

进程三种状态：运行、就绪和阻塞。

** 进程 API
一个之前读 TLPI 没有留意的点：exec() 不返回，它后面的代码不会被执行。

** 受限直接运行

问题：如果对程序运行没有限制，那么我们怎样保证安全性，如何停下并切换？

方案：区分用户态和内核态，用户态下代码受限（比如不能发出 I/O）。内核态可以访问所有的资源。

内核 trap 表：记录那些异常对应那些代码。

问题： *如何重获 CPU 控制权* ？

方案一：等待系统调用。缺陷：我就是不用系统调用，你能奈我何？

方案二：非协作方式。时钟中断。

上下文切换：系统需要保存当前执行进程的寄存器的值，恢复将要执行的进程寄存器的值。

** 进程调度

   - Note taken on [2020-03-15 日 14:28] \\
     其实我觉得 STCF 还有个问题：系统怎么之后完成时间？
1. FIFO: 如果有某些任务占用时间特别多，那就 over 了。
2. SJF（最短任务优先）。处理不了任务随时进入的情况。
3. STCF（最短完成任务优先）。如果任务运行时间太长，新任务时间比它短，让新任务抢占它的时间。但是如果考虑响应时间（收到任务到任务被执行的时间），STCF 就不太好用了。
4. RR（轮转）。

两种策略：

SJF 和 STCF 优化了周转时间（任务结束时间），RR 优化了响应时间（但是对周转时间不利）。

再考虑 IO，还有系统不知道结束时间。

本章结束。

** 调度：多级反馈队列

MLFQ(Multi-level feedback quue)。

*** 基本规则

多个优先队列，每个队列用 RR 策略，核心就在于如果调整优先级。

规则1: 先运行高优先级的任务；

规则2：同优先级队列任务采用 RR；

*** 尝试1: 改变优先级

规则3: 任务进入系统时，放入最高优先级队列；

规则4: 任务用完一个时间片之后，降低优先级；

规则5: 用完时间片前主动释放的任务，优先级不变；

这里假设了所有任务都是短任务，如果任务时间长，则会放入低优先级的队列，这跟 SJF 接近。
