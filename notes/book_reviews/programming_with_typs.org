#+TITLE: 《编程与类型系统》笔记
#+OPTIONS: ^:nil
#+HTML_HEAD: <link rel="stylesheet" href="https://latex.now.sh/style.css">
* chap10 泛型算法和迭代器
** 10.1
用迭代器实现了 ~map()~, ~filter~, 和 ~reduce()~.
** 10.2
如何实现链式调用 ~t.map(f).filter(g).reduce()~: 实现一个类，主要的数据成员是迭代器，在里面实现 ~map()~ 和 ~filter()~ 让它们接受 ~this~ 的迭代器成员，然后返回一个迭代器。
** 10.3
#+BEGIN_QUOTE
类型参数的约束：约束告诉编译器某个类型实参必须具有的能力……一旦要求泛型类型上必须有特定成员，就使用约束将允许类型的集合限制为具有必要成员的那些类型。
#+END_QUOTE

例子：

1. 哈希集合的实现要求对应的泛型类型有哈希方法。
2. 类似 ~max()~ 一类的方法需要泛型参数有比较方法。
** 10.4
利用数组实现高效的 ~reverse()~ (其实就是原地翻转，不用额外的空间)。

要做对应泛型迭代器的版本，我们需要迭代器能向前向后移动，能比较（这样我们可以知道何时迭代结束）。按照这种方法，我们可以实现双链表的 ~reverse()~ .这一节我们实现了更多特殊的迭代器。

#+BEGIN_QUOTE
输入迭代器：输入迭代器是能够遍历序列一次并提供其值的迭代器。它不能第二次重放值，因为值可能已经不再可用。
#+END_QUOTE

#+BEGIN_QUOTE
输出迭代器：输出迭代器是能够遍历一个序列并向其写入值的迭代器，并不需要读出值。

输出迭代器的例子：写入到输出流。
#+END_QUOTE

#+BEGIN_QUOTE
前向迭代器：是可以向前推进、可以读取/更新当前位置的值的迭代器。可以克隆，这样允许多次遍历同一个序列。
#+END_QUOTE

#+BEGIN_QUOTE
双向迭代器：在前向迭代器的基础上，增加向后移动的能力。
#+END_QUOTE
