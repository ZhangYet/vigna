#+TITLE: 《编程与类型系统》笔记
#+OPTIONS: ^:nil
#+OPTIONS: num:nil
#+HTML_HEAD: <link rel="stylesheet" href="https://latex.now.sh/style.css">
* chap10 泛型算法和迭代器
** 10.1
用迭代器实现了 ~map()~, ~filter~, 和 ~reduce()~.
** 10.2
如何实现链式调用 ~t.map(f).filter(g).reduce()~: 实现一个类，主要的数据成员是迭代器，在里面实现 ~map()~ 和 ~filter()~ 让它们接受 ~this~ 的迭代器成员，然后返回一个迭代器。
** 10.3
#+BEGIN_QUOTE
类型参数的约束：约束告诉编译器某个类型实参必须具有的能力……一旦要求泛型类型上必须有特定成员，就使用约束将允许类型的集合限制为具有必要成员的那些类型。
#+END_QUOTE

例子：

1. 哈希集合的实现要求对应的泛型类型有哈希方法。
2. 类似 ~max()~ 一类的方法需要泛型参数有比较方法。
** 10.4
利用数组实现高效的 ~reverse()~ (其实就是原地翻转，不用额外的空间)。

要做对应泛型迭代器的版本，我们需要迭代器能向前向后移动，能比较（这样我们可以知道何时迭代结束）。按照这种方法，我们可以实现双链表的 ~reverse()~ .这一节我们实现了更多特殊的迭代器。

#+BEGIN_QUOTE
输入迭代器：输入迭代器是能够遍历序列一次并提供其值的迭代器。它不能第二次重放值，因为值可能已经不再可用。
#+END_QUOTE

#+BEGIN_QUOTE
输出迭代器：输出迭代器是能够遍历一个序列并向其写入值的迭代器，并不需要读出值。

输出迭代器的例子：写入到输出流。
#+END_QUOTE

#+BEGIN_QUOTE
前向迭代器：是可以向前推进、可以读取/更新当前位置的值的迭代器。可以克隆，这样允许多次遍历同一个序列。
#+END_QUOTE

#+BEGIN_QUOTE
双向迭代器：在前向迭代器的基础上，增加向后移动的能力。
#+END_QUOTE

#+BEGIN_QUOTE
随机访问迭代器：能够以常量时间向前和向后跳过任意多个元素。
#+END_QUOTE
** 10.5
实现自适应的算法，一个例子是 elementAt 算法：如果是随机访问迭代器，可以用常量时间访问，如果只是前向迭代器，那就只能一步一步向前了。
* chap11 高阶类型及其他
** 11.1
考虑将 ~map~ 实现到 ~Option<T>~ 上（考虑 typescript 支持和类型，所以实现到 ~T|undefined~ 即可）。

#+BEGIN_QUOTE
函子：接受一个泛型类型和一个从类型到类型的函数，返回一个泛型类型的函数。

如： ~map(v: Box<T>, func: (value: T) => U): Box<U>~ 则 ~map~ 是一个函子。
#+END_QUOTE

#+BEGIN_QUOTE
高阶类型：泛型类型是具有类型参数的类型，高阶类型代表具有另外一个类型参数的来性参数，如 ~Box<T<U>>~ 和 ~T<U>~
#+END_QUOTE

这一章是怎样从普通的 ~map~ 扩展到函子的呢？

函数的函子：给定一个有任意实参且返回类型 ~T~ 的函数，我们可以 *映射* 一个函数，该函数接受 ~T~ 作为实参，返回一个 ~U~ ，组合出来的函数就是从任意实参到 ~U~ 的一个函数。这个 *映射* 就是函数的函子[fn:1]。

* Footnotes

[fn:1] 这个定义是我概括的，另外有个问题是：这不就是数学里面的组合函数么？ 
