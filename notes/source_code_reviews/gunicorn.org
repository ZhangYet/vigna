#+TITLE: gunicorn 源码阅读笔记
#+OPTIONS: ^:nil
#+OPTIONS: num:nil
#+HTML_HEAD: <link rel="stylesheet" href="https://latex.now.sh/style.css">
源码阅读最重要的就是搞清楚「我希望在阅读过程中解决什么问题」。
* gunicorn 在初始化的时候做了什么？
当我们执行诸如 ~gunicorn --workers=3 --worker-class=gevent test:app~ 这样的命令时， gunicorn 的入口是 ~wsgiapp.run()~, 它初始化了 ~WSGIApplication~ 类并运行它的 ~run()~ 方法。
** WSGIApplication 类的初始化

 ~WSGIApplication~ 类继承 ~Application~ 类， 重载了 ~init()~, ~load_config()~ 和 ~load()~ 方法。 ~Application~ 类继承了 ~BaseApplication~ 类，重载了 ~load_config()~ 和 ~run()~ 方法。

 初始化 ~WSGIApplication~ 类就是执行 ~BaseApplication~ 类的 ~__init__()~ 方法。这个方法初始化了类属性，并调用 ~do_load_config()~ 方法。

 ~do_load_config()~ 方法会先调用 ~load_default_config()~ 方法初始化一个 ~Config~ 类实例。然后调用 ~load_config()~ 方法——因为类继承的关系，这里的调用的是 ~WSGIApplication~ 类的 ~load_config()~ 方法（这个方法会通过 ~super()~ 调用 ~BaseApplication~ 类中的 ~load_config()~ ）。

至此，初始化的工作完成，注意到此时我们需要 serve 的 app 还没有实际载入。这个初始化过程没有太多复杂的逻辑，显得绕是因为有两层继承关系。
** run()
初始化完策划那个的 ~WSGIApplication~ 实例会执行 ~Application~ 的 ~run()~ 方法（因为没有重载），如果设置了 ~--print-config~ 或者 ~--check-config~ ，那么实例会执行 ~load()~ 方法，然后退出。此外还有 daemonize 的相应逻辑，重点在 ~BaseApplication~ 类的 ~run()~ 方法。

在 ~BaseApplication~ 的 ~run()~ 方法中， ~BaseApplication~ 会把实例本身作为参数初始化 ~Arbiter~ 类，并执行 ~Arbiter~ 类的 ~run()~ 方法。 ~Arbiter~ 类是整个 gunicorn 的核心。

~Arbiter~ 类初始化只是做了一点成员赋值的工作，里面的 ~setup()~ 逻辑会将传入的 ~BaseApplication~ 类实例赋值给 ~Arbiter.app~ 属性。此外会确定工作目录，以及使用的 python 解释器路径。如果配置中有 preload_app 配置，那么调用 ~Application.wsgi()~ 方法，载入实际的 application 。

~Arbiter~ 类的 ~run()~ 方法实现了整个事件循环。
*** Arbiter.run()
**** start()
~Arbiter~ 的 ~start()~ 方法先取 pid（如果配置了 pidfile，创建 pidfile[fn:1]），随后执行 ~on_starting~ hook。

然后执行 ~init_signals()~ 方法。这个方法会创建一个 PIPE （ ~self.PIPE~ ）[fn:2]， ~self.PIPE~ 会用于进程间通信[fn:3]。 然后实例会为关注的信号注册对应的信号方法[fn:4]。SIGCHLD 有单独的处理函数（其他的处理函数只需要 ~wakeup()~ 而 SIGCHLD 的会先 ~reap_workers()~ ）。

之后处理 self.LISTENERS[fn:5]。无论如何都会调用 ~systemd.sd_notify()~ 方法。

最后调用 ~when_ready~ hook。
**** 事件循环

* gunicorn 信号处理
* gunicorn 是如何处理请求的

*** Arbiter 类的初始化

* Footnotes

[fn:5] 这个属性我不知道干什么用的，这一段逻辑应该跟 [[https://docs.gunicorn.org/en/stable/deploy.html][systemd 部署 gunicorn]] 有关。 

[fn:4] 注册信号的写法其实挺风骚的： ~SIGNALS = [getattr(signal, "SIG%s" % x) for x in "HUP QUIT INT TERM TTIN TTOU USR1 USR2 WINCH".split()]~  ，而且我也不知道为什么要处理 SIGWINCH , gunicorn 在 deamon 状态下， 收到 SIGWINCH 会优雅关闭 workder 进程，并把 worker 进程数设置为0。查了一下， Nginx 也会这样梳理 SIGWINCH 不知道为什么。

[fn:3] 这里的说法其实有问题，在写到这里的时候，我还不知道这个 PIPE 的作用。 

[fn:2] 这里有一处写法我不明白，为什么要先关掉 ~self.PIPE~ 里面的两个 fd？我不明白的地方是：按道理这里 ~self.PIPE~ 应该是空的，想不到为什么要 close 一下。

[fn:1] 为什么要有 pidfile ？
 
