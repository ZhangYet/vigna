** 共享库高级特性

*** 动态加载库

就是到真正要调用某个库的某个函数的时候，才去查找(或加载)对应的库函数。

**** ~dlopen()~

载入共享库（如果对应的库有依赖，会把依赖也一起载入）。

每次调用都会增加库的引用计数，但是只会在第一次调用时载入，每次 ~dlclose()~ 的时候都会把引用计数减去。引用计数为 0 的时候会从内存中将库删除。

如果载入一个别的程序已经载入的库会怎样？

**** ~dlsym()~

这个调用坑爹的地方在于，出错它也返回 NULL，找不到也返回 NULL，要结合 ~dlerror()~ 才知道是找不到还是出错了。

如果要找的 symbol 是函数，那么会有一点小麻烦：

#+BEGIN_SRC c
int (*funcp)(int); // 一个指向接收一个整型返回一个整型的函数指针
*(void **) (&funcp) = dlsym(handle, symbol); // 复杂吧？
(void *) funcp = dlsym(handle, symbol); // 这种没有那么复杂，但是编译器会有警告。
#+END_SRC

**** 在主程序中访问符号
假如我们用 ~dlopen()~ 加载一个库，有希望库里面的函数访问主程序中的符号，我们需要在编译的时候加上 ~--export-dynamic~ 。

*** 控制符号的可见性

~static~ 使一个符号私有于一个源代码模块，从而使它无法被其他目标文件绑定。同时，所有对该符号的引用都会绑定到这个符号上（不用担心被覆盖了）。

*** 版本脚本

可以控制哪些符号被导出，哪些符号不可见。
