** 散列表

*** 直接寻址表

这没啥好说的。

*** 散列表

碰撞： 两个关键字映射到同一个槽上。

**** 链表

同一个槽中的元素都放在一个链表上。

1. 插入： 插入槽中链表的 head；
2. 查找： 找到槽的链表，然后顺着链表比对 key;
3. 删除： 找到槽的链表，然后顺着链表找到 key 删除；

使用链表的散列表一次成功 查找需要 \theta(1+n/m) n:元素数目；m：槽位。

*** 散列函数

跳过。

*** 开放寻址法

hash 函数为 h(x, k) k 是迭代次数，第一次找不到就找第二次，如此类推。

1. 插入：h(x, i) 为空就插入，当然，如果所有的槽都满了，就要抛出异常。
2. 搜索：顺着 h(x, i) 找，找到就返回，遇到 nil 就知道找不到，所有槽都找过也知道找不到。
3. 删除：标注 deleted，但是这样搜索就会有麻烦（因为遇到 deleted 还得继续搜索）[fn:1]。

**** 线性探查

#+BEGIN_LaTeX
h(k, i) = (h^{'}(k)+i) mod m
#+END_LaTeX

探查相邻的槽位，有个问题：一次群集。

**** 二次探查

#+BEGIN_LaTeX
h(k, i) = (h^{'}(k)+c_{1}i+c_{2}i^2) mod m
#+END_LaTeX

居然还有二次群集。因为如果两个 key 在 i=0 相同了，那么其他 i 的情况下，key 映射出来的结果也是相同的。

**** 双重散列

#+BEGIN_LaTeX
h(k, i) = (h_{1}(k) + ih_{2}(k)) mod m
#+END_LaTeX

为什么双重散列比线性探查和二次探查效果好？它的探查序列有 m m^2 种，更接近一致散列的要求[fn:2]。

*** 完全散列

跳过了。

*** Footnotes

[fn:2] 就是说，每个关键字探查序列都 0, ……, m 的 m! 种排列种任意一种可能性是相同的。

[fn:1] 所以需要删除的 hash table 一般都是使用链表。
